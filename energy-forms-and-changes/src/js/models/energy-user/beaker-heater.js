define(function (require) {

    'use strict';

    var _ = require('underscore');
    
    var Vector2 = require('common/math/vector2');

    var EnergyUser            = require('models/energy-user');
    var EnergyChunkPathMover  = require('models/energy-chunk-path-mover');
    var EnergyChunkCollection = require('models/energy-chunk-collection');
    var EnergyChunk           = require('models/energy-chunk');
    var Beaker                = require('models/element/beaker');
    var Thermometer           = require('models/element/thermometer');

    var Constants = require('constants');
    var EnergyTypes = Constants.EnergyTypes;
    var HeatTransfer = Constants.HeatTransfer;

    /**
     * Basic building block model for all the elements in the intro tab scene
     */
    var BeakerHeater = EnergyUser.extend({

        defaults: _.extend({}, EnergyUser.prototype.defaults, {
            // Proportion, from 0 to 1, of the max possible heat being generated by heater element.
            heatProportion: 0,

            // Most other classes don't need this info this info, and really it should be designed
            //   to not need it, but for the sake of sticking with the original algorithms and not
            //   introducing new bugs, we're going to keep it. 
            energyChunksVisible: false
        }),
        
        initialize: function(attributes, options) {
            EnergyUser.prototype.initialize.apply(this, [attributes, options]);

            // Cached objects
            this._position = new Vector2();
            this._extractionPoint = new Vector2();

            // Energy chunk movers
            this.electricalEnergyChunkMovers = [];
            this.heatingElementEnergyChunkMovers = [];
            this.radiatedEnergyChunkMovers = [];

            // Separate list for the radiated energy chunks so that they can be
            //   handled a little differently in the view
            this.radiatedEnergyChunks = new EnergyChunkCollection();

            // Beaker
            this.beaker = new Beaker({
                position: BeakerHeater.BEAKER_OFFSET,
                width:    BeakerHeater.BEAKER_WIDTH,
                height:   BeakerHeater.BEAKER_HEIGHT
            });
            var beaker = this.beaker;
            
            // Thermometer
            this.thermometer = new Thermometer({
                position: BeakerHeater.THERMOMETER_OFFSET,
                attached: true, // It's attached to the beaker permanently
                active: true
            }, {
                elementLocator: {
                    getElementAtLocation: function() { return beaker; }
                }
            });

            // Updating child elements' positions
            this.on('change:position', function(model, position){
                this.beaker.setPosition(this._position.set(this.get('position')).add(BeakerHeater.BEAKER_OFFSET));
                this.thermometer.setPosition(this._position.set(this.get('position')).add(BeakerHeater.THERMOMETER_OFFSET));
            });
        },  

        update: function(time, deltaTime, incomingEnergy) {
            if (this.active()) {
                // Handle any incoming energy chunks
                this.handleIncomingEnergyChunks();

                // Move some energy chunks
                this.moveElectricalEnergyChunks(deltaTime);
                this.moveThermalEnergyChunks(deltaTime);

                // Updating the heating proportion according to incoming energy
                this.updateHeatingProportion(deltaTime, incomingEnergy);

                // Exchange energy between the beaker and everything else
                this.updateBeakerEnergy(deltaTime);

                // Move the last energy chunks
                this.moveRadiatedEnergyChunks(deltaTime);
            }
        },

        handleIncomingEnergyChunks: function() {
            var chunk;
            for (var i = this.incomingEnergyChunks.length - 1; i >= 0; i--) {
                chunk = this.incomingEnergyChunks.models[i];
                if (chunk.get('energyType') === EnergyTypes.ELECTRICAL) {
                    // Add the energy chunk to the list of those under management.
                    this.energyChunks.add(chunk);
                    this.incomingEnergyChunks.remove(chunk);

                    // And a "mover" that will move this energy chunk through
                    //   the wire to the bulb.
                    this.electricalEnergyChunkMovers.push(new EnergyChunkPathMover(
                        chunk,
                        this.createElectricalEnergyChunkPath(this.get('position')),
                        Constants.ENERGY_CHUNK_VELOCITY
                    ));
                }
                else {
                    // By design, this shouldn't happen, so warn if it does.
                    console.error('BeakerHeater - Warning: Ignoring energy chunk with unexpected type, type = ' + chunk.get('energyType'));
                }
            }
        },

        updateBeakerEnergy: function(deltaTime) {
            // Add energy to the beaker based on heat coming from heat element.
            this.beaker.changeEnergy(this.get('heatProportion') * BeakerHeater.MAX_HEAT_GENERATION_RATE * deltaTime);

            // Remove energy from the beaker based on loss of heat to the
            //   surrounding air.
            var temperatureGradient = this.beaker.getTemperature() - Constants.ROOM_TEMPERATURE;
            if (Math.abs(temperatureGradient) > Constants.TEMPERATURES_EQUAL_THRESHOLD) {
                // Calculate the thermal contact area
                var beakerRect = this.beaker.getRawOutlineRect();
                var thermalContactArea = (beakerRect.w * 2) + (beakerRect.h * 2) * this.beaker.get('fluidLevel');

                // Calculate thermal energy lost to the air
                var thermalEnergyLost = temperatureGradient * HeatTransfer.WATER_AIR_HEAT_TRANSFER_FACTOR * thermalContactArea * deltaTime;
                this.beaker.changeEnergy(-thermalEnergyLost);

                // Prevent the water from going beyond the boiling point.
                if (this.beaker.getEnergyBeyondMaxTemperature() > 0)
                    this.beaker.changeEnergy(-beaker.getEnergyBeyondMaxTemperature());
            }

            if (this.beaker.getEnergyChunkBalance() > 0) {
                // Remove an energy chunk from the beaker and start it floating
                //   away, a.k.a. make it "radiate".
                var extractionPoint = this._extractionPoint.set(
                    this.beaker.getRect().left() + Math.random() * this.beaker.getRect().w,
                    this.beaker.getRect().bottom() + Math.random() * (this.beaker.getRect().h * this.beaker.get('fluidLevel'))
                );
                var chunk = this.beaker.extractClosestEnergyChunk(extractionPoint);
                if (chunk) {
                    chunk.set('zPosition', 0); // Move to front of z order.
                    
                    this.radiatedEnergyChunks.add(chunk);
                    this.radiatedEnergyChunkMovers.push(new EnergyChunkPathMover(
                        chunk,
                        this.createRadiatedEnergyChunkPath(chunk.get('position')),
                        Constants.ENERGY_CHUNK_VELOCITY
                    ));
                }
            }
        },

        updateHeatingProportion: function(deltaTime, incomingEnergy) {
            var heatProportion;
            if ((this.get('energyChunksVisible') && this.heatingElementEnergyChunkMovers.length > 0) ||
                (!this.get('energyChunksVisible') && incomingEnergy.type == EnergyTypes.ELECTRICAL) 
            ) {
                heatProportion = Math.min(
                    incomingEnergy.amount / (Constants.MAX_ENERGY_PRODUCTION_RATE * deltaTime),
                    this.get('heatProportion') + BeakerHeater.HEAT_ENERGY_CHANGE_RATE * deltaTime
                );
            }
            else {
                heatProportion = Math.max(0, this.get('heatProportion') - BeakerHeater.HEAT_ENERGY_CHANGE_RATE * deltaTime);
            }
            this.set('heatProportion', heatProportion);
        },

        moveRadiatedEnergyChunks: function(deltaTime) {
            for (var i = this.radiatedEnergyChunkMovers.length - 1; i >= 0; i--) {
                this.radiatedEnergyChunkMovers[i].moveAlongPath(deltaTime);
                if (this.radiatedEnergyChunkMovers[i].finished()) {
                    // Remove the chunk and its mover
                    this.energyChunks.remove(this.radiatedEnergyChunkMovers[i].energyChunk);
                    this.radiatedEnergyChunkMovers.splice(i, 1);
                }
            }
        },

        moveThermalEnergyChunks: function(deltaTime) {
            for (var i = this.heatingElementEnergyChunkMovers.length - 1; i >= 0; i--) {
                this.heatingElementEnergyChunkMovers[i].moveAlongPath(deltaTime);
                if (this.heatingElementEnergyChunkMovers[i].finished()) {
                    /// The chunk is ready to move to the beaker.  We remove it
                    //   from here, and the beaker takes over management of the
                    //   chunk.
                    this.beaker.addEnergyChunk(this.heatingElementEnergyChunkMovers[i].energyChunk);
                    this.energyChunks.remove(this.heatingElementEnergyChunkMovers[i].energyChunk);
                    this.heatingElementEnergyChunkMovers.splice(i, 1);
                }
            }
        },

        moveElectricalEnergyChunks: function(deltaTime) {
            var chunk;
            for (var i = this.electricalEnergyChunkMovers.length - 1; i >= 0; i--) {
                this.electricalEnergyChunkMovers[i].moveAlongPath(deltaTime);
                if (this.electricalEnergyChunkMovers[i].finished()) {
                    // The electrical energy chunk has reached the burner, so
                    //   it needs to change into thermal energy.
                    chunk = this.electricalEnergyChunkMovers[i].energyChunk;
                    chunk.set('energyType', EnergyTypes.THERMAL);

                    // Remove the old mover
                    this.electricalEnergyChunkMovers.splice(i, 1);

                    // Create a new mover, where it will move a little on the
                    //   element before moving into the beaker.
                    this.heatingElementEnergyChunkMovers.push(new EnergyChunkPathMover(
                        chunk,
                        this.createHeaterElementEnergyChunkPath(chunk.get('position')),
                        BeakerHeater.HEATING_ELEMENT_ENERGY_CHUNK_VELOCITY
                    ));
                }
            }
        },

        preloadEnergyChunks: function(incomingEnergyRate) {
            this.clearEnergyChunks();
            if (incomingEnergyRate.amount === 0 || incomingEnergyRate.type !== EnergyTypes.ELECTRICAL) {
                // No energy chunk pre-loading needed.
                return;
            }

            var deltaTime = 1 / Constants.FRAMES_PER_SECOND;
            var energySinceLastChunk = Constants.ENERGY_PER_CHUNK * 0.99;

            // Simulate energy chunks moving through the system
            var preloadingComplete = false;
            while (!preloadingComplete) {
                energySinceLastChunk += incomingEnergyRate.amount * deltaTime;

                // Determine if time to add a new chunk
                if (energySinceLastChunk >= Constants.ENERGY_PER_CHUNK) {
                    var initialPosition = this._initialChunkPosition
                        .set(this.get('position'))
                        .add(BeakerHeater.OFFSET_TO_LEFT_SIDE_OF_WIRE);

                    var newChunk = new EnergyChunk({
                        energyType: EnergyTypes.ELECTRICAL,
                        position: initialPosition
                    });

                    // Add a 'mover' for this energy chunk
                    this.electricalEnergyChunkMovers.push(new EnergyChunkPathMover(
                        newChunk,
                        this.createElectricalEnergyChunkPath(this.get('position')),
                        Constants.ENERGY_CHUNK_VELOCITY
                    ));

                    // Update energy since last chunk
                    energySinceLastChunk -= Constants.ENERGY_PER_CHUNK;
                }

                this.moveElectricalEnergyChunks(deltaTime);

                if (this.heatingElementEnergyChunkMovers.length > 1) {
                    // A couple of chunks are radiating, which completes the pre-load.
                    preloadingComplete = true;
                }
            }
        },

        createElectricalEnergyChunkPath: function(centerPosition) {
            return [
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_LEFT_SIDE_OF_WIRE_BEND),
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_FIRST_WIRE_CURVE_POINT),
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_SECOND_WIRE_CURVE_POINT),
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_THIRD_WIRE_CURVE_POINT),
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_BOTTOM_OF_CONNECTOR),
                centerPosition.clone().add(BeakerHeater.OFFSET_TO_CONVERSION_POINT)
            ];
        },

        createHeaterElementEnergyChunkPath: function(startPosition) {
            // The path for the thermal energy chunks is meant to look like it
            //   is moving on the burner element.  This must be manually
            //   coordinated with the burner element image.
            var angle;
            if (Math.random() >= 0.5)
                angle = Math.random() * Math.PI * 0.45;
            else
                angle = -Math.random() * Math.PI * 0.3;
            return [
                new Vector2(0, BeakerHeater.HEATER_ELEMENT_HEIGHT).rotate(angle).add(startPosition)
            ];
        },

        createRadiatedEnergyChunkPath: function(startPosition) {
            var nominalTravelVector = BeakerHeater.RADIATION_NOMINAL_TRAVEL_VECTOR;
            var path = [];

            // The first point is straight above the start point.  This just looks
            //   good, making the chunk move straight up out of the beaker.
            var currentPosition = startPosition.clone().add(nominalTravelVector);
            path.push(currentPosition);

            // Add the remaining points in the path.
            for (var i = 0; i < BeakerHeater.RADIATION_NUM_DIRECTION_CHANGES - 1; i++) {
                var movement = nominalTravelVector.clone().rotate((Math.random() - 0.5) * Math.PI / 4);
                path.push(movement.add(currentPosition));
            }

            return path;
        },

        injectEnergyChunks: function(energyChunks) {
            this.incomingEnergyChunks.add(energyChunks);
        },

        clearEnergyChunks: function() {
            EnergyUser.prototype.clearEnergyChunks.apply(this);

            this.electricalEnergyChunkMovers = [];
            this.filamentEnergyChunkMovers = [];
            this.radiatedEnergyChunkMovers = [];

            this.radiatedEnergyChunks.reset();
        },

        deactivate: function() {
            EnergyUser.prototype.deactivate.apply(this);
            this.set('heatProportion', 0);
            this.beaker.reset();
            this.beaker.setPosition(this._position.set(this.get('position')).add(BeakerHeater.BEAKER_OFFSET));
        }

    }, Constants.BeakerHeater);

    return BeakerHeater;
});
